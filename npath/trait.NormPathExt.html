<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `NormPathExt` trait in crate `npath`."><meta name="keywords" content="rust, rustlang, rust-lang, NormPathExt"><title>npath::NormPathExt - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script id="default-settings"></script><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../favicon.svg">
<link rel="alternate icon" type="image/png" href="../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc trait"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../npath/index.html'><div class='logo-container rust-logo'><img src='../rust-logo.png' alt='logo'></div></a><p class="location">Trait NormPathExt</p><div class="sidebar-elems"><div class="block items"><a class="sidebar-title" href="#required-methods">Required Methods</a><div class="sidebar-links"><a href="#tymethod.lexical_join">lexical_join</a><a href="#tymethod.absolute">absolute</a><a href="#tymethod.base">base</a><a href="#tymethod.dir">dir</a><a href="#tymethod.is_inside">is_inside</a><a href="#tymethod.normalized">normalized</a><a href="#tymethod.relative_to">relative_to</a><a href="#tymethod.resolved">resolved</a><a href="#tymethod.rooted_join">rooted_join</a><a href="#tymethod.try_rooted_join">try_rooted_join</a></div><a class="sidebar-title" href="#foreign-impls">Implementations on Foreign Types</a><div class="sidebar-links"><a href="#impl-NormPathExt-for-Path">Path</a></div><a class="sidebar-title" href="#implementors">Implementors</a></div><p class="location"><a href="index.html">npath</a></p><div id="sidebar-vars" data-name="NormPathExt" data-ty="trait" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" class="help-button">?</button>
                <a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Trait <a href="index.html">npath</a>::<wbr><a class="trait" href="">NormPathExt</a></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/npath/lib.rs.html#193-579" title="goto source code">[src]</a></span></h1><div class="docblock type-decl hidden-by-usual-hider"><pre class="rust trait">pub trait NormPathExt {
    fn <a href="#tymethod.absolute" class="fnname">absolute</a>(&amp;self) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.PathBuf.html" title="struct std::path::PathBuf">PathBuf</a>&gt;;
<div class="item-spacer"></div>    fn <a href="#tymethod.base" class="fnname">base</a>(&amp;self) -&gt; &amp;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.Path.html" title="struct std::path::Path">Path</a>;
<div class="item-spacer"></div>    fn <a href="#tymethod.dir" class="fnname">dir</a>(&amp;self) -&gt; &amp;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.Path.html" title="struct std::path::Path">Path</a>;
<div class="item-spacer"></div>    fn <a href="#tymethod.is_inside" class="fnname">is_inside</a>&lt;P:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.Path.html" title="struct std::path::Path">Path</a>&gt;&gt;(&amp;self, base: P) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>;
<div class="item-spacer"></div>    fn <a href="#tymethod.normalized" class="fnname">normalized</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.PathBuf.html" title="struct std::path::PathBuf">PathBuf</a>;
<div class="item-spacer"></div>    fn <a href="#tymethod.lexical_join" class="fnname">lexical_join</a>&lt;P:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.Path.html" title="struct std::path::Path">Path</a>&gt;&gt;(&amp;self, path: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.PathBuf.html" title="struct std::path::PathBuf">PathBuf</a>;
<div class="item-spacer"></div>    fn <a href="#tymethod.relative_to" class="fnname">relative_to</a>&lt;P:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.Path.html" title="struct std::path::Path">Path</a>&gt;&gt;(&amp;self, base: P) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.PathBuf.html" title="struct std::path::PathBuf">PathBuf</a>&gt;;
<div class="item-spacer"></div>    fn <a href="#tymethod.resolved" class="fnname">resolved</a>(&amp;self) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.PathBuf.html" title="struct std::path::PathBuf">PathBuf</a>&gt;;
<div class="item-spacer"></div>    fn <a href="#tymethod.rooted_join" class="fnname">rooted_join</a>&lt;P:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.Path.html" title="struct std::path::Path">Path</a>&gt;&gt;(&amp;self, path: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.PathBuf.html" title="struct std::path::PathBuf">PathBuf</a>;
<div class="item-spacer"></div>    fn <a href="#tymethod.try_rooted_join" class="fnname">try_rooted_join</a>&lt;P:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.Path.html" title="struct std::path::Path">Path</a>&gt;&gt;(&amp;self, path: P) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.PathBuf.html" title="struct std::path::PathBuf">PathBuf</a>&gt;;
}</pre></div><div class="docblock"><p>Extension trait for <a href="https://doc.rust-lang.org/nightly/std/path/struct.Path.html" title="Path"><code>Path</code></a>.</p>
</div><h2 id="required-methods" class="small-section-header">Required methods<a href="#required-methods" class="anchor"></a></h2><div class="methods"><h3 id="tymethod.absolute" class="method"><code>fn <a href="#tymethod.absolute" class="fnname">absolute</a>(&amp;self) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.PathBuf.html" title="struct std::path::PathBuf">PathBuf</a>&gt;</code><a class="srclink" href="../src/npath/lib.rs.html#213" title="goto source code">[src]</a></h3><div class="docblock"><p>Returns the absolute equivalent of <code>self</code>.</p>
<ul>
<li>If <code>self</code> is absolute, it it is returned as is.</li>
<li>If <code>self</code> is relative, it is lexically joined to <a href="https://doc.rust-lang.org/nightly/std/env/fn.current_dir.html" title="std::env::current_dir"><code>std::env::current_dir</code></a>.</li>
</ul>
<h1 id="examples" class="section-header"><a href="#examples">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">path</span>::{<span class="ident">Path</span>, <span class="ident">PathBuf</span>};
<span class="kw">use</span> <span class="ident">npath</span>::<span class="ident">NormPathExt</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;/usr&quot;</span>).<span class="ident">absolute</span>().<span class="ident">unwrap</span>(), <span class="ident">PathBuf</span>::<span class="ident">from</span>(<span class="string">&quot;/usr&quot;</span>));

<span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Ok</span>(<span class="ident">cwd</span>) <span class="op">=</span> <span class="ident">std</span>::<span class="ident">env</span>::<span class="ident">current_dir</span>() {
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;lib&quot;</span>).<span class="ident">absolute</span>().<span class="ident">unwrap</span>(), <span class="ident">cwd</span>.<span class="ident">lexical_join</span>(<span class="string">&quot;lib&quot;</span>));
}</pre></div>
</div><h3 id="tymethod.base" class="method"><code>fn <a href="#tymethod.base" class="fnname">base</a>(&amp;self) -&gt; &amp;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.Path.html" title="struct std::path::Path">Path</a></code><a class="srclink" href="../src/npath/lib.rs.html#239" title="goto source code">[src]</a></h3><div class="docblock"><p>Returns the last path component of <code>self</code>.</p>
<p>See <a href="http://man7.org/linux/man-pages/man3/basename.3.html"><code>basename(3)</code></a>.</p>
<h1 id="differences-with-pathfile_name" class="section-header"><a href="#differences-with-pathfile_name">Differences with <code>Path::file_name</code></a></h1>
<ul>
<li>Always returns a path (eventually <code>/</code>, <code>.</code>, or <code>..</code>, when <a href="https://doc.rust-lang.org/nightly/std/path/struct.Path.html#method.file_name" title="Path::file_name"><code>Path::file_name</code></a> returns
<code>None</code>).</li>
<li>Returns a <a href="https://doc.rust-lang.org/nightly/std/path/struct.Path.html" title="Path"><code>Path</code></a> instead of an <a href="https://doc.rust-lang.org/nightly/std/ffi/os_str/struct.OsStr.html"><code>OsStr</code></a>.</li>
</ul>
<h1 id="examples-1" class="section-header"><a href="#examples-1">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">path</span>::<span class="ident">Path</span>;
<span class="kw">use</span> <span class="ident">npath</span>::<span class="ident">NormPathExt</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;/usr/lib&quot;</span>).<span class="ident">base</span>(), <span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;lib&quot;</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;/usr/&quot;</span>).<span class="ident">base</span>(),    <span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;usr&quot;</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;usr/.&quot;</span>).<span class="ident">base</span>(),    <span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;.&quot;</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;usr&quot;</span>).<span class="ident">base</span>(),      <span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;usr&quot;</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;/&quot;</span>).<span class="ident">base</span>(),        <span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;/&quot;</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;.&quot;</span>).<span class="ident">base</span>(),        <span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;.&quot;</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;..&quot;</span>).<span class="ident">base</span>(),       <span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;..&quot;</span>));</pre></div>
</div><h3 id="tymethod.dir" class="method"><code>fn <a href="#tymethod.dir" class="fnname">dir</a>(&amp;self) -&gt; &amp;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.Path.html" title="struct std::path::Path">Path</a></code><a class="srclink" href="../src/npath/lib.rs.html#263" title="goto source code">[src]</a></h3><div class="docblock"><p>Returns <code>self</code> up to, but not including, the final component.</p>
<p>See <a href="http://man7.org/linux/man-pages/man3/dirname.3.html"><code>dirname(3)</code></a>.</p>
<h1 id="differences-with-pathparent" class="section-header"><a href="#differences-with-pathparent">Differences with <code>Path::parent</code></a></h1>
<p>Always returns a path (<code>/</code> when <a href="https://doc.rust-lang.org/nightly/std/path/struct.Path.html#method.parent" title="Path::parent"><code>Path::parent</code></a> returns <code>None</code>).</p>
<h1 id="examples-2" class="section-header"><a href="#examples-2">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">path</span>::<span class="ident">Path</span>;
<span class="kw">use</span> <span class="ident">npath</span>::<span class="ident">NormPathExt</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;/usr/lib&quot;</span>).<span class="ident">dir</span>(), <span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;/usr&quot;</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;/usr/&quot;</span>).<span class="ident">dir</span>(),    <span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;/&quot;</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;usr/.&quot;</span>).<span class="ident">dir</span>(),    <span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;usr&quot;</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;usr&quot;</span>).<span class="ident">dir</span>(),      <span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;.&quot;</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;/&quot;</span>).<span class="ident">dir</span>(),        <span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;/&quot;</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;.&quot;</span>).<span class="ident">dir</span>(),        <span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;.&quot;</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;..&quot;</span>).<span class="ident">dir</span>(),       <span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;.&quot;</span>));</pre></div>
</div><h3 id="tymethod.is_inside" class="method"><code>fn <a href="#tymethod.is_inside" class="fnname">is_inside</a>&lt;P:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.Path.html" title="struct std::path::Path">Path</a>&gt;&gt;(&amp;self, base: P) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class="srclink" href="../src/npath/lib.rs.html#326" title="goto source code">[src]</a></h3><div class="docblock"><p>Returns whether <code>self</code> is lexically inside <code>base</code>.</p>
<p><code>self</code> is considered &quot;lexically inside&quot; <code>base</code> (or a descendant of <code>base</code>) if and only if:</p>
<ul>
<li><code>self</code> and <code>base</code> are both relative, or both absolute.</li>
<li><code>self</code> does not have any component outside of <code>base</code>.</li>
</ul>
<p>Both paths are normalized before being compared.</p>
<h1 id="limitations" class="section-header"><a href="#limitations">Limitations</a></h1>
<p>When processing relative paths, if it is necessary to know the absolute path of either
<code>base</code> or <code>self</code>, this method returns <code>false</code>:</p>
<ul>
<li>If <code>base</code> is absolute and <code>self</code> is relative, or the opposite, there is no way to know
where <code>base</code> points to relative to <code>self</code> without using the absolute path of the CWD.</li>
<li>If <code>base</code> and <code>self</code> are relative, and <code>base</code> is re-entrant (a parent component <code>..</code> is
followed by a normal component), it is not possible to know whether <code>base</code> re-enters the
directory it just left, or if it branches off to a sibling directory, without using the
absolute path of the CWD. (Note that <code>self</code> can be re-entrant as shown in the examples.)</li>
</ul>
<p>To circumvent these limitations, you can ensure both path are absolute using one of these
methods:</p>
<ul>
<li><a href="../npath/trait.NormPathExt.html#tymethod.absolute" title="NormPathExt::absolute"><code>NormPathExt::absolute</code></a>: with the limitations of <a href="../npath/trait.NormPathExt.html#tymethod.normalized" title="NormPathExt::normalized"><code>NormPathExt::normalized</code></a>.</li>
<li><a href="https://doc.rust-lang.org/nightly/std/path/struct.Path.html#method.canonicalize" title="Path::canonicalize"><code>Path::canonicalize</code></a>: without the limitations of <a href="../npath/trait.NormPathExt.html#tymethod.normalized" title="NormPathExt::normalized"><code>NormPathExt::normalized</code></a>, but both
paths must exist on the filesystem.</li>
</ul>
<h1 id="windows" class="section-header"><a href="#windows">Windows</a></h1>
<p>Paths components are compared in a case-insensitive way only for the ASCII character set
(first 128 Unicode characters). For paths containing characters outside of this range, this
method could return <code>false</code> even though <code>self</code> is inside <code>base</code> on the filesystem.</p>
<h1 id="examples-3" class="section-header"><a href="#examples-3">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">path</span>::<span class="ident">Path</span>;
<span class="kw">use</span> <span class="ident">npath</span>::<span class="ident">NormPathExt</span>;

<span class="comment">// Both absolute</span>
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;/srv&quot;</span>).<span class="ident">is_inside</span>(<span class="string">&quot;/&quot;</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;/srv&quot;</span>).<span class="ident">is_inside</span>(<span class="string">&quot;/srv&quot;</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;/srv/file.txt&quot;</span>).<span class="ident">is_inside</span>(<span class="string">&quot;/srv&quot;</span>));

<span class="comment">// Both relative</span>
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;srv&quot;</span>).<span class="ident">is_inside</span>(<span class="string">&quot;srv&quot;</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;srv&quot;</span>).<span class="ident">is_inside</span>(<span class="string">&quot;.&quot;</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;srv&quot;</span>).<span class="ident">is_inside</span>(<span class="string">&quot;..&quot;</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;../srv&quot;</span>).<span class="ident">is_inside</span>(<span class="string">&quot;..&quot;</span>)); <span class="comment">// self is re-entrent</span>

<span class="comment">// One absolute, the other relative</span>
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;file.txt&quot;</span>).<span class="ident">is_inside</span>(<span class="string">&quot;/srv&quot;</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;/srv/file.txt&quot;</span>).<span class="ident">is_inside</span>(<span class="string">&quot;srv&quot;</span>));

<span class="comment">// self exits base</span>
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;/srv/..&quot;</span>).<span class="ident">is_inside</span>(<span class="string">&quot;/srv&quot;</span>));

<span class="comment">// base is re-entrent</span>
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;srv&quot;</span>).<span class="ident">is_inside</span>(<span class="string">&quot;../foo&quot;</span>));</pre></div>
</div><h3 id="tymethod.normalized" class="method"><code>fn <a href="#tymethod.normalized" class="fnname">normalized</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.PathBuf.html" title="struct std::path::PathBuf">PathBuf</a></code><a class="srclink" href="../src/npath/lib.rs.html#366" title="goto source code">[src]</a></h3><div class="docblock"><p>Returns the normalized equivalent of <code>self</code>.</p>
<p>The returned path is the shortest equivalent, normalized by pure lexical processing with
the following rules:</p>
<ol>
<li>Replace repeated <code>/</code> with a single one.</li>
<li>Eliminate <code>.</code> path components (the current directory).</li>
<li>Simplify inner <code>..</code> path components (the parent directory), including components
preceded by a rooted path (replace <code>/..</code> by <code>/</code>).</li>
</ol>
<h1 id="differences-with-pathcanonicalize" class="section-header"><a href="#differences-with-pathcanonicalize">Differences with <code>Path::canonicalize</code></a></h1>
<p>This function <strong>does not touch the filesystem, ever</strong>:</p>
<ul>
<li>It does not resolve symlinks.</li>
<li>It does not check if files/directories exist.</li>
<li>If the given path is relative, it returns a relative path.</li>
</ul>
<h1 id="limitations-1" class="section-header"><a href="#limitations-1">Limitations</a></h1>
<p>If <code>/a/b</code> is a symlink to <code>/d/e</code>, then for <code>/a/b/../c</code>:</p>
<ul>
<li><a href="https://doc.rust-lang.org/nightly/std/path/struct.Path.html#method.canonicalize" title="Path::canonicalize"><code>Path::canonicalize</code></a> returns <code>/d/c</code>.</li>
<li><a href="../npath/trait.NormPathExt.html#tymethod.normalized" title="NormPathExt::normalized"><code>NormPathExt::normalized</code></a> returns <code>/a/c</code>.</li>
</ul>
<h1 id="examples-4" class="section-header"><a href="#examples-4">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">path</span>::{<span class="ident">Path</span>, <span class="ident">PathBuf</span>};
<span class="kw">use</span> <span class="ident">npath</span>::<span class="ident">NormPathExt</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;usr/lib&quot;</span>).<span class="ident">normalized</span>(),                 <span class="ident">PathBuf</span>::<span class="ident">from</span>(<span class="string">&quot;usr/lib&quot;</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;usr//lib&quot;</span>).<span class="ident">normalized</span>(),                <span class="ident">PathBuf</span>::<span class="ident">from</span>(<span class="string">&quot;usr/lib&quot;</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;usr/lib/.&quot;</span>).<span class="ident">normalized</span>(),               <span class="ident">PathBuf</span>::<span class="ident">from</span>(<span class="string">&quot;usr/lib&quot;</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;usr/lib/gcc/..&quot;</span>).<span class="ident">normalized</span>(),          <span class="ident">PathBuf</span>::<span class="ident">from</span>(<span class="string">&quot;usr/lib&quot;</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;/../usr/lib&quot;</span>).<span class="ident">normalized</span>(),             <span class="ident">PathBuf</span>::<span class="ident">from</span>(<span class="string">&quot;/usr/lib&quot;</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;/../usr/bin/../././/lib&quot;</span>).<span class="ident">normalized</span>(), <span class="ident">PathBuf</span>::<span class="ident">from</span>(<span class="string">&quot;/usr/lib&quot;</span>));</pre></div>
</div><h3 id="tymethod.lexical_join" class="method"><code>fn <a href="#tymethod.lexical_join" class="fnname">lexical_join</a>&lt;P:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.Path.html" title="struct std::path::Path">Path</a>&gt;&gt;(&amp;self, path: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.PathBuf.html" title="struct std::path::PathBuf">PathBuf</a></code><a class="srclink" href="../src/npath/lib.rs.html#409" title="goto source code">[src]</a></h3><div class="docblock"><p>Returns <code>path</code> lexically joined to <code>self</code>.</p>
<h1 id="differences-with-pathjoin" class="section-header"><a href="#differences-with-pathjoin">Differences with <code>Path::join</code></a></h1>
<p>If <code>path</code> is absolute, it does not replace <code>self</code>.</p>
<h1 id="limitations-2" class="section-header"><a href="#limitations-2">Limitations</a></h1>
<p>On Windows, this method can turn paths without UNC prefixes into paths that have one.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">path</span>::{<span class="ident">Component</span>, <span class="ident">Path</span>, <span class="ident">PathBuf</span>};
<span class="kw">use</span> <span class="ident">npath</span>::<span class="ident">NormPathExt</span>;

<span class="kw">fn</span> <span class="ident">has_prefix</span>(<span class="ident">path</span>: <span class="kw-2">&amp;</span><span class="ident">Path</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">bool</span> {
    <span class="ident">path</span>.<span class="ident">components</span>().<span class="ident">next</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">c</span><span class="op">|</span> <span class="macro">matches</span><span class="macro">!</span>(<span class="ident">c</span>, <span class="ident">Component</span>::<span class="ident">Prefix</span>(<span class="kw">_</span>))).<span class="ident">unwrap_or</span>(<span class="bool-val">false</span>)
}

<span class="macro">assert_eq</span><span class="macro">!</span>(
    <span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">r&quot;\\server&quot;</span>).<span class="ident">lexical_join</span>(<span class="string">r&quot;c$\file.txt&quot;</span>),
    <span class="ident">PathBuf</span>::<span class="ident">from</span>(<span class="string">r&quot;\\server\c$\file.txt&quot;</span>),
);</pre></div>
<h1 id="examples-5" class="section-header"><a href="#examples-5">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">path</span>::{<span class="ident">Path</span>, <span class="ident">PathBuf</span>};
<span class="kw">use</span> <span class="ident">npath</span>::<span class="ident">NormPathExt</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(
    <span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;/usr&quot;</span>)
        .<span class="ident">lexical_join</span>(<span class="string">&quot;bin&quot;</span>)   <span class="comment">// relative</span>
        .<span class="ident">lexical_join</span>(<span class="string">&quot;/cat&quot;</span>), <span class="comment">// absolute</span>
    <span class="ident">PathBuf</span>::<span class="ident">from</span>(<span class="string">&quot;/usr/bin/cat&quot;</span>)
);

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;/usr&quot;</span>).<span class="ident">lexical_join</span>(<span class="string">&quot;..&quot;</span>), <span class="ident">PathBuf</span>::<span class="ident">from</span>(<span class="string">&quot;/usr/..&quot;</span>));</pre></div>
</div><h3 id="tymethod.relative_to" class="method"><code>fn <a href="#tymethod.relative_to" class="fnname">relative_to</a>&lt;P:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.Path.html" title="struct std::path::Path">Path</a>&gt;&gt;(&amp;self, base: P) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.PathBuf.html" title="struct std::path::PathBuf">PathBuf</a>&gt;</code><a class="srclink" href="../src/npath/lib.rs.html#462" title="goto source code">[src]</a></h3><div class="docblock"><p>Returns the normalized relative path from <code>base</code> to <code>self</code>.</p>
<p>If <code>self</code> cannot be made relative to <code>base</code>, the method returns <code>None</code>. The returned path,
if any, satisfies: <code>base.join(path) == self</code>. Both paths are normalized before being
compared, and the returned path is also normalized.</p>
<h1 id="limitations-3" class="section-header"><a href="#limitations-3">Limitations</a></h1>
<p>The method returns <code>None</code> when it cannot determine the intermediate path components to
reach <code>self</code> from <code>base</code>, or fetching the CWD is required:</p>
<ul>
<li>One path is absolute, but the other is relative.</li>
<li>The paths are relative, <code>base</code> is above <code>self</code>, and they are both above the CWD (knowing
its intermediate components is necessary).</li>
</ul>
<p>To circumvent these limitations, you can ensure both path are absolute using one of these
methods:</p>
<ul>
<li><a href="../npath/trait.NormPathExt.html#tymethod.absolute" title="NormPathExt::absolute"><code>NormPathExt::absolute</code></a>: with the limitations of <a href="../npath/trait.NormPathExt.html#tymethod.normalized" title="NormPathExt::normalized"><code>NormPathExt::normalized</code></a>.</li>
<li><a href="https://doc.rust-lang.org/nightly/std/path/struct.Path.html#method.canonicalize" title="Path::canonicalize"><code>Path::canonicalize</code></a>: without the limitations of <a href="../npath/trait.NormPathExt.html#tymethod.normalized" title="NormPathExt::normalized"><code>NormPathExt::normalized</code></a>, but both
paths must exist on the filesystem.</li>
</ul>
<h1 id="windows-1" class="section-header"><a href="#windows-1">Windows</a></h1>
<p>There is an inescapable limitation when the paths refer to different locations (different
drives, or network shares): there is no relative path between them because they are not in
the same namespace.</p>
<p>Paths components are compared in a case-insensitive way only for the ASCII character set
(first 128 Unicode characters). For paths containing characters outside of this range, this
method could return <code>None</code> even though there is a relative path from <code>base</code> to <code>self</code> on
the filesystem.</p>
<h1 id="examples-6" class="section-header"><a href="#examples-6">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">path</span>::{<span class="ident">Path</span>, <span class="ident">PathBuf</span>};
<span class="kw">use</span> <span class="ident">npath</span>::<span class="ident">NormPathExt</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;/usr/lib&quot;</span>).<span class="ident">relative_to</span>(<span class="string">&quot;/usr&quot;</span>), <span class="prelude-val">Some</span>(<span class="ident">PathBuf</span>::<span class="ident">from</span>(<span class="string">&quot;lib&quot;</span>)));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;usr/bin&quot;</span>).<span class="ident">relative_to</span>(<span class="string">&quot;var&quot;</span>),   <span class="prelude-val">Some</span>(<span class="ident">PathBuf</span>::<span class="ident">from</span>(<span class="string">&quot;../usr/bin&quot;</span>)));

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;lib&quot;</span>).<span class="ident">relative_to</span>(<span class="string">&quot;/usr&quot;</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;/usr&quot;</span>).<span class="ident">relative_to</span>(<span class="string">&quot;var&quot;</span>), <span class="prelude-val">None</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;foo&quot;</span>).<span class="ident">relative_to</span>(<span class="string">&quot;/&quot;</span>),  <span class="prelude-val">None</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;foo&quot;</span>).<span class="ident">relative_to</span>(<span class="string">&quot;..&quot;</span>), <span class="prelude-val">None</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;..&quot;</span>).<span class="ident">relative_to</span>(<span class="string">&quot;.&quot;</span>), <span class="prelude-val">Some</span>(<span class="ident">PathBuf</span>::<span class="ident">from</span>(<span class="string">&quot;..&quot;</span>)));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;.&quot;</span>).<span class="ident">relative_to</span>(<span class="string">&quot;..&quot;</span>), <span class="prelude-val">None</span>);</pre></div>
</div><h3 id="tymethod.resolved" class="method"><code>fn <a href="#tymethod.resolved" class="fnname">resolved</a>(&amp;self) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.PathBuf.html" title="struct std::path::PathBuf">PathBuf</a>&gt;</code><a class="srclink" href="../src/npath/lib.rs.html#516" title="goto source code">[src]</a></h3><div class="docblock"><p>Returns the normalized equivalent of <code>self</code>, with intermediate symlinks resolved.</p>
<p>The longest prefix of <code>self</code> where each component exist on the filesystem is canonicalized,
the remaining path is lexically adjoined, and the result is normalized.</p>
<p>If <code>self</code> is relative and no prefix component exists in the CWD (no prefix can be
canonicalized), then the result is relative (it is simply the normalized equivalent of
<code>self</code>). Use <a href="../npath/trait.NormPathExt.html#tymethod.absolute" title="NormPathExt::absolute"><code>NormPathExt::absolute</code></a> to ensure this method returns an absolute path.</p>
<h1 id="differences-with-pathcanonicalize-1" class="section-header"><a href="#differences-with-pathcanonicalize-1">Differences with <code>Path::canonicalize</code></a></h1>
<ul>
<li>This method works for paths that do not exist on the filesystem.</li>
<li>The path is normalized with the same limitations as <a href="../npath/trait.NormPathExt.html#tymethod.normalized" title="NormPathExt::normalized"><code>NormPathExt::normalized</code></a>. In
particular, a suffix might contain <code>..</code> components that can replace canonicalized
components.</li>
<li>The returned path can be relative.</li>
</ul>
<h1 id="differences-with-normpathextnormalized" class="section-header"><a href="#differences-with-normpathextnormalized">Differences with <code>NormPathExt::normalized</code></a></h1>
<ul>
<li>This method does not perform pure lexical processing, and returns a <a href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="std::io::Result"><code>std::io::Result</code></a>.</li>
<li>The prefix that is canonicalized has its intermediate symlinks resolved, without the
limitations of <a href="../npath/trait.NormPathExt.html#tymethod.normalized" title="NormPathExt::normalized"><code>NormPathExt::normalized</code></a>.</li>
</ul>
<h1 id="limitations-4" class="section-header"><a href="#limitations-4">Limitations</a></h1>
<p>The prefix considered for canonicalization ends at the first component of <code>self</code> that does
not exist. The only exception is if the whole path exists, then it is canonicalized in
full.</p>
<p>For example, assuming only <code>usr</code> and <code>usr/lib</code> exist, <code>usr/liz/../lib/rust</code> refers to
<code>usr/lib/rust</code>, but only <code>usr</code> is canonicalized since neither <code>usr/lib/rust</code> nor <code>usr/liz</code>
exist.</p>
<p><a href="../npath/trait.NormPathExt.html#tymethod.normalized" title="NormPathExt::normalized"><code>NormPathExt::normalized</code></a> limitations apply in most cases. If you need to get the true
canonical path, use <a href="https://doc.rust-lang.org/nightly/std/path/struct.Path.html#method.canonicalize" title="Path::canonicalize"><code>Path::canonicalize</code></a>.</p>
<h1 id="examples-7" class="section-header"><a href="#examples-7">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">path</span>::{<span class="ident">Path</span>, <span class="ident">PathBuf</span>};
<span class="kw">use</span> <span class="ident">npath</span>::<span class="ident">NormPathExt</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;usr/lib&quot;</span>).<span class="ident">resolved</span>().<span class="ident">unwrap</span>(),                 <span class="ident">PathBuf</span>::<span class="ident">from</span>(<span class="string">&quot;usr/lib&quot;</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;usr//lib&quot;</span>).<span class="ident">resolved</span>().<span class="ident">unwrap</span>(),                <span class="ident">PathBuf</span>::<span class="ident">from</span>(<span class="string">&quot;usr/lib&quot;</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;usr/lib/.&quot;</span>).<span class="ident">resolved</span>().<span class="ident">unwrap</span>(),               <span class="ident">PathBuf</span>::<span class="ident">from</span>(<span class="string">&quot;usr/lib&quot;</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;usr/lib/gcc/..&quot;</span>).<span class="ident">resolved</span>().<span class="ident">unwrap</span>(),          <span class="ident">PathBuf</span>::<span class="ident">from</span>(<span class="string">&quot;usr/lib&quot;</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;/usr/lib&quot;</span>).<span class="ident">resolved</span>().<span class="ident">unwrap</span>(),                <span class="ident">PathBuf</span>::<span class="ident">from</span>(<span class="string">&quot;/usr/lib&quot;</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;/../usr/lib&quot;</span>).<span class="ident">resolved</span>().<span class="ident">unwrap</span>(),             <span class="ident">PathBuf</span>::<span class="ident">from</span>(<span class="string">&quot;/usr/lib&quot;</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;/usr/bin/../././/lib&quot;</span>).<span class="ident">resolved</span>().<span class="ident">unwrap</span>(),    <span class="ident">PathBuf</span>::<span class="ident">from</span>(<span class="string">&quot;/usr/lib&quot;</span>));</pre></div>
</div><h3 id="tymethod.rooted_join" class="method"><code>fn <a href="#tymethod.rooted_join" class="fnname">rooted_join</a>&lt;P:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.Path.html" title="struct std::path::Path">Path</a>&gt;&gt;(&amp;self, path: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.PathBuf.html" title="struct std::path::PathBuf">PathBuf</a></code><a class="srclink" href="../src/npath/lib.rs.html#549" title="goto source code">[src]</a></h3><div class="docblock"><p>Returns <code>path</code> restricted to <code>self</code>.</p>
<p>This methods works as if <code>self</code> was the root directory. The returned path is guaranteed to
be lexically inside <code>self</code>.</p>
<h1 id="differences-with-normpathexttry_rooted_join" class="section-header"><a href="#differences-with-normpathexttry_rooted_join">Differences with <code>NormPathExt::try_rooted_join</code></a></h1>
<p>It does not return an error since the returned path is always inside <code>self</code>.</p>
<h1 id="limitations-5" class="section-header"><a href="#limitations-5">Limitations</a></h1>
<ul>
<li>Same limitations as <a href="../npath/trait.NormPathExt.html#tymethod.normalized" title="NormPathExt::normalized"><code>NormPathExt::normalized</code></a>.</li>
<li>The result can have a different meaning than what was intended since all the prefix <code>..</code>
components are stripped away.</li>
</ul>
<h1 id="examples-8" class="section-header"><a href="#examples-8">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">path</span>::{<span class="ident">Path</span>, <span class="ident">PathBuf</span>};
<span class="kw">use</span> <span class="ident">npath</span>::<span class="ident">NormPathExt</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;/srv&quot;</span>).<span class="ident">rooted_join</span>(<span class="string">&quot;file.txt&quot;</span>),           <span class="ident">PathBuf</span>::<span class="ident">from</span>(<span class="string">&quot;/srv/file.txt&quot;</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;/srv&quot;</span>).<span class="ident">rooted_join</span>(<span class="string">&quot;/file.txt&quot;</span>),          <span class="ident">PathBuf</span>::<span class="ident">from</span>(<span class="string">&quot;/srv/file.txt&quot;</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;/srv&quot;</span>).<span class="ident">rooted_join</span>(<span class="string">&quot;../file.txt&quot;</span>),        <span class="ident">PathBuf</span>::<span class="ident">from</span>(<span class="string">&quot;/srv/file.txt&quot;</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;/srv&quot;</span>).<span class="ident">rooted_join</span>(<span class="string">&quot;foo/../file.txt&quot;</span>),    <span class="ident">PathBuf</span>::<span class="ident">from</span>(<span class="string">&quot;/srv/file.txt&quot;</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;/srv&quot;</span>).<span class="ident">rooted_join</span>(<span class="string">&quot;foo/../../file.txt&quot;</span>), <span class="ident">PathBuf</span>::<span class="ident">from</span>(<span class="string">&quot;/srv/file.txt&quot;</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(
    <span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;/srv&quot;</span>).<span class="ident">rooted_join</span>(<span class="string">&quot;../srv/file.txt&quot;</span>),
    <span class="ident">PathBuf</span>::<span class="ident">from</span>(<span class="string">&quot;/srv/srv/file.txt&quot;</span>)
);</pre></div>
</div><h3 id="tymethod.try_rooted_join" class="method"><code>fn <a href="#tymethod.try_rooted_join" class="fnname">try_rooted_join</a>&lt;P:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.Path.html" title="struct std::path::Path">Path</a>&gt;&gt;(&amp;self, path: P) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.PathBuf.html" title="struct std::path::PathBuf">PathBuf</a>&gt;</code><a class="srclink" href="../src/npath/lib.rs.html#578" title="goto source code">[src]</a></h3><div class="docblock"><p>Returns <code>path</code> restricted to <code>self</code>.</p>
<p><code>self</code> and <code>path</code> are converted to absolute paths with <a href="../npath/trait.NormPathExt.html#tymethod.absolute" title="NormPathExt::absolute"><code>NormPathExt::absolute</code></a>, they are
joined with <a href="../npath/trait.NormPathExt.html#tymethod.lexical_join" title="NormPathExt::lexical_join"><code>NormPathExt::lexical_join</code></a>, and the result is normalized with
<a href="../npath/trait.NormPathExt.html#tymethod.normalized" title="NormPathExt::normalized"><code>NormPathExt::normalized</code></a>.</p>
<h1 id="differences-with-normpathextrooted_join" class="section-header"><a href="#differences-with-normpathextrooted_join">Differences with <code>NormPathExt::rooted_join</code></a></h1>
<p>If the result points to a location outside of <code>base</code>, this method returns an error.</p>
<h1 id="examples-9" class="section-header"><a href="#examples-9">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">path</span>::{<span class="ident">Path</span>, <span class="ident">PathBuf</span>};
<span class="kw">use</span> <span class="ident">npath</span>::<span class="ident">NormPathExt</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;/srv&quot;</span>).<span class="ident">try_rooted_join</span>(<span class="string">&quot;file.txt&quot;</span>).<span class="ident">unwrap</span>(),        <span class="ident">PathBuf</span>::<span class="ident">from</span>(<span class="string">&quot;/srv/file.txt&quot;</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;/srv&quot;</span>).<span class="ident">try_rooted_join</span>(<span class="string">&quot;/file.txt&quot;</span>).<span class="ident">unwrap</span>(),       <span class="ident">PathBuf</span>::<span class="ident">from</span>(<span class="string">&quot;/srv/file.txt&quot;</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;/srv&quot;</span>).<span class="ident">try_rooted_join</span>(<span class="string">&quot;foo/../file.txt&quot;</span>).<span class="ident">unwrap</span>(), <span class="ident">PathBuf</span>::<span class="ident">from</span>(<span class="string">&quot;/srv/file.txt&quot;</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(
    <span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;/srv&quot;</span>).<span class="ident">try_rooted_join</span>(<span class="string">&quot;../srv/file.txt&quot;</span>).<span class="ident">unwrap</span>(),
    <span class="ident">PathBuf</span>::<span class="ident">from</span>(<span class="string">&quot;/srv/file.txt&quot;</span>)
);

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;/srv&quot;</span>).<span class="ident">try_rooted_join</span>(<span class="string">&quot;../file.txt&quot;</span>).<span class="ident">is_err</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;/srv&quot;</span>).<span class="ident">try_rooted_join</span>(<span class="string">&quot;foo/../../file.txt&quot;</span>).<span class="ident">is_err</span>());</pre></div>
</div></div><span class="loading-content">Loading content...</span><h2 id="foreign-impls" class="small-section-header">Implementations on Foreign Types<a href="#foreign-impls" class="anchor"></a></h2><h3 id="impl-NormPathExt-for-Path" class="impl"><code class="in-band">impl <a class="trait" href="../npath/trait.NormPathExt.html" title="trait npath::NormPathExt">NormPathExt</a> for <a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.Path.html" title="struct std::path::Path">Path</a></code><a href="#impl-NormPathExt-for-Path" class="anchor"></a><a class="srclink" href="../src/npath/lib.rs.html#581-802" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.absolute" class="method hidden"><code>fn <a href="#method.absolute" class="fnname">absolute</a>(&amp;self) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.PathBuf.html" title="struct std::path::PathBuf">PathBuf</a>&gt;</code><a class="srclink" href="../src/npath/lib.rs.html#582-588" title="goto source code">[src]</a></h4><h4 id="method.base" class="method hidden"><code>fn <a href="#method.base" class="fnname">base</a>(&amp;self) -&gt; &amp;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.Path.html" title="struct std::path::Path">Path</a></code><a class="srclink" href="../src/npath/lib.rs.html#590-602" title="goto source code">[src]</a></h4><h4 id="method.dir" class="method hidden"><code>fn <a href="#method.dir" class="fnname">dir</a>(&amp;self) -&gt; &amp;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.Path.html" title="struct std::path::Path">Path</a></code><a class="srclink" href="../src/npath/lib.rs.html#604-625" title="goto source code">[src]</a></h4><h4 id="method.is_inside" class="method hidden"><code>fn <a href="#method.is_inside" class="fnname">is_inside</a>&lt;P:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.Path.html" title="struct std::path::Path">Path</a>&gt;&gt;(&amp;self, base: P) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class="srclink" href="../src/npath/lib.rs.html#628-656" title="goto source code">[src]</a></h4><h4 id="method.normalized" class="method hidden"><code>fn <a href="#method.normalized" class="fnname">normalized</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.PathBuf.html" title="struct std::path::PathBuf">PathBuf</a></code><a class="srclink" href="../src/npath/lib.rs.html#658-689" title="goto source code">[src]</a></h4><h4 id="method.lexical_join" class="method hidden"><code>fn <a href="#method.lexical_join" class="fnname">lexical_join</a>&lt;P:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.Path.html" title="struct std::path::Path">Path</a>&gt;&gt;(&amp;self, path: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.PathBuf.html" title="struct std::path::PathBuf">PathBuf</a></code><a class="srclink" href="../src/npath/lib.rs.html#691-693" title="goto source code">[src]</a></h4><h4 id="method.relative_to" class="method hidden"><code>fn <a href="#method.relative_to" class="fnname">relative_to</a>&lt;P:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.Path.html" title="struct std::path::Path">Path</a>&gt;&gt;(&amp;self, base: P) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.PathBuf.html" title="struct std::path::PathBuf">PathBuf</a>&gt;</code><a class="srclink" href="../src/npath/lib.rs.html#695-745" title="goto source code">[src]</a></h4><h4 id="method.resolved" class="method hidden"><code>fn <a href="#method.resolved" class="fnname">resolved</a>(&amp;self) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.PathBuf.html" title="struct std::path::PathBuf">PathBuf</a>&gt;</code><a class="srclink" href="../src/npath/lib.rs.html#751-776" title="goto source code">[src]</a></h4><h4 id="method.rooted_join" class="method hidden"><code>fn <a href="#method.rooted_join" class="fnname">rooted_join</a>&lt;P:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.Path.html" title="struct std::path::Path">Path</a>&gt;&gt;(&amp;self, path: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.PathBuf.html" title="struct std::path::PathBuf">PathBuf</a></code><a class="srclink" href="../src/npath/lib.rs.html#778-780" title="goto source code">[src]</a></h4><h4 id="method.try_rooted_join" class="method hidden"><code>fn <a href="#method.try_rooted_join" class="fnname">try_rooted_join</a>&lt;P:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.Path.html" title="struct std::path::Path">Path</a>&gt;&gt;(&amp;self, path: P) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.PathBuf.html" title="struct std::path::PathBuf">PathBuf</a>&gt;</code><a class="srclink" href="../src/npath/lib.rs.html#784-801" title="goto source code">[src]</a></h4></div><span class="loading-content">Loading content...</span><h2 id="implementors" class="small-section-header">Implementors<a href="#implementors" class="anchor"></a></h2><div class="item-list" id="implementors-list"></div><span class="loading-content">Loading content...</span><script type="text/javascript" src="../implementors/npath/trait.NormPathExt.js" async></script></section><section id="search" class="content hidden"></section><section class="footer"></section><div id="rustdoc-vars" data-root-path="../" data-current-crate="npath"></div>
    <script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>